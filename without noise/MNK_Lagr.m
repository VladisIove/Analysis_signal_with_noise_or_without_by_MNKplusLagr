function [a,L,xi]=MNK_Lagr(x,y,N)
%x - Початковий вектор аргументів
%y - Початковий вектор значень функції
%N - Кількість точок у початковому векторі
%xі - Інтерпольований вектор аргументів
%a - Вектор значень апроксимованої функції
%L - Вектор значень інтерпольованої функції
ly=length(y);%Довжина сигналу
lx=length(x);%Довжина вектора часу
%-----------------------------------------
%Визначення степеня двійки
%-----------------------------------------
i=0;%Інкремент
div=ly/(2^i);
while div>1
    div=ly/(2^(i+1));
    if div>=1
        i=i+1;
    end
end
%-----------------------------------------
%Визначення остачі від ділення на 2^i
%-----------------------------------------
if ly-2^i~=0%Умова наявності остачі
    Info=['Довжина сигналу складає ' num2str(ly) ' відліки'];
    disp('-----------------------------------------------------')
    disp(Info)
    disp('-----------------------------------------------------')
    Info=['Найближча степінь двійки, i=' num2str(i)];
    disp(Info)
    disp('-----------------------------------------------------')
    Ost=ly-2^i;%Остача від ділення на 2^i
    Info=['Остача від ділення на 2^i=' num2str(Ost)];
    disp(Info)
    disp('-----------------------------------------------------')
    %-----------------------------------------
    %Інтерполяція
    %-----------------------------------------
    na=15;%Початкова кількість точок у відрізку
    while (rem(lx,na)~=0)
        na=na+1;%Визначення дільника, більшого за 15
        %-----------------------------------------
        %Зменшення кількості початкових відліків до ділення на 32
        %-----------------------------------------
        if na>40
            ji=32*floor(lx/32);
            jj=floor(lx/(lx-ji))-1;
            j=jj;
            while(lx~=ji)
                x(j)=[];
                y(j)=[];
                j=j+jj;
                lx=length(x);
                ly=length(y);
            end
            na=30;
        end
        %-----------------------------------------
    end
    inTo=2^(i+1)-ly;%Визначення кількості відліків, необхідних для інтерполяції
    Na=fix(ly/na);%Визначення кількості відрізків інтерполяції
    vpls=fix(inTo/Na);%Кількість додаткових точок
    add=rem(inTo,Na);%Неповна кількість відліків, для додавання у відрізки
    Lint=vpls+na+1;
    for j=1:Na
        nl=(j-1)*na+1;
        kl=na*j;
        nli=(j-1)*Lint+1;
        kli=Lint*j;
        [xi(nli:kli),L(nli:kli)]=Lagr_rep(x(nl:kl),y(nl:kl),Lint);
        %Видалення зайвих елементів (кінець алгоритму на 115 рядку)
        index(nli:kli)=0;
        for ji=nl:kl
            for jj=nli:kli
                if xi(jj)==x(ji)
                    index(jj)=1;
                end
            end
        end
        if add~=0
            if j==add
                xint=xi;
            end
        else
            xint=1;
        end
    end
    ji=Na-add;
    j=1;
    while (ji~=0)
        for jj=(length(xint)+(j-1)*Lint+round(Lint/10)):1:length(xi)%(length(xi)-round(Lint/10)):-j:length(xint)
            if index(jj)==0
                xi(jj)=66666666666666666.6666666666666;
                ji=ji-1;
                j=j+1;
                break;
            end
        end
    end
    j = 1;
    while j <= length(xi)
        if xi(j)==66666666666666666.6666666666666
            xi(j)=[];
            L(j)=[];
        else
            j=j+1;
        end
    end
a=MNK_Part(xi, L);
else
    Ost=0;%Остача від ділення на 2^i
    Info=['Довжина сигналу складає ' num2str(ly) ' відліки'];
    disp('-----------------------------------------------------')
    disp(Info)
    disp('-----------------------------------------------------')
    disp('Остача від ділення на 2^i відсутня')
    disp('-----------------------------------------------------')
    Info=['Cтепінь двійки, i=' num2str(i)];
    disp(Info)
    disp('-----------------------------------------------------')
a=MNK_Part(x, y);    
L=y;
xi=x;
end